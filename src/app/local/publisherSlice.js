import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";

// import { baseAPI } from "@/app/services/baseApi";
import { ENDPOINTS } from "@/utils/constants/apiConstants";

import { baseAPI } from "../services/fetchers";

export const setLegalAsync = createAsyncThunk(
  "publisher/setLegal",
  async (data) => {
    try {
      const { uId, status } = data;
      let end_ = ENDPOINTS.PUBLISHER_SET_LEGAL_STATUS.replace("{user_id}", uId);
      end_ = end_.replace("{status}", status);

      const response = await baseAPI({
        endPoint: end_,
      });
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    } catch (e) {
      return e.response.data;
    }
  }
);

const slice = createSlice({
  name: "publisher",
  initialState: {
    legal: null,
    detail: null,
    loading: false,
    error: null,
  },
  reducers: {
    clearState: (state) => {
      state.loading = false;
      state.error = null;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    // builder.addCase(setLegalAsync.pending, (state) => {
    //   state.loading = true;
    //   state.error = null;
    // });
    builder.addCase(setLegalAsync.fulfilled, (state, action) => {
      state.loading = false;
      if (action.payload.success) {
        state.legal = action.payload;
      } else {
        state.error = action.payload;
      }
    });
    // builder.addCase(setLegalAsync.rejected, (state, action) => {
    //   state.loading = false;
    //   state.error = action.error;
    // });
  },
});

export const { updateUser, clearState } = slice.actions;

export default slice.reducer;

export const selectCurrentUser = (state) => state.user.profile;

export const publisherSetLegal = (data) => async (dispatch) => {
  return dispatch(setLegalAsync(data));
};
